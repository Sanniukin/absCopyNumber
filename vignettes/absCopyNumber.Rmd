---
title: "absCopyNumber: Tumor Purity, Ploidy and Absolute Copy Number Estimator"
author: "Shixiang Wang \\
        ShanghaiTech. University"
date: "`r Sys.Date()`"

output:
  prettydoc::html_pretty:
    toc: true
    theme: cayman
    highlight: github
  pdf_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Tumor Purity, Ploidy and Absolute Copy Number Estimation}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = F
)
```


```{r load_pkg, echo=FALSE, results="hide", warning=FALSE,message=FALSE}
# suppressPackageStartupMessages({
#   if("absCopyNumber" %in% installed.packages()[,1]) {
#     library(absCopyNumber)
#   } else {
#     devtools::load_all(".")
#   }
# })
```


The goal of absCopyNumber is to Estimate tumor purity, ploidy and absolute copy numbers from NGS (WGS, WES, Target Sequencing) and Microarray (SNP, aCGH etc.) data, based on statistical method from paper â€” "*AbsCN-seq: a statistical method to estimate tumor purity, ploidy and absolute copy numbers from next-generation sequencing data*".

There are two systems in this package to compute absolute copy number and corresponding purity and ploidy pair, one come from [absCNseq package](https://github.com/ShixiangWang/absCNseq) (not maintained), which used for NGS data (I modified some code and extend it for microarray data, like SNP array, I will not maintain except find big bug), the other one is a pipeline I built on the core of absCNseq using OOP (it is more easier and will be maintained).  The statistical method come from `AbsCN-seq` is very robust and easy to use, I test it for SNP array and think it can definitely handle microarray data. If you have doubts if it can be applied to microarray data, please read the "Comparison between ABSOLUTE and absCopyNumber for SNP" part and decide whether or not to use it for microarray data.

Next I wanna add "Bayesian Optimization" to minimize object function, it may be get more robust solution than "Grid Search".


## Installation 

You can install absCopyNumber from github with:

```{r gh-installation, eval = FALSE}
# install.packages("devtools")
devtools::install_github("ShixiangWang/absCopyNumber")
```

## Load 

```{r library_pkg, eval=T}
library(absCopyNumber)
```

Help page, run

```{r, eval=F}
??absCopyNumber
```


## New Class

This part will introduce user how to use `initialize`, `prepare` and `calling` 3 steps to finish pipeline of absolute copy number calling and estimation of purity and ploidy.

### Support Input

```{r}
abs_supportfiles()
```

### initialize

This step load file or data.frame into absCopyNumber object using `abs_initialize` function.

Firstly, we use some variables to store example files within this package.

```{r ident_filepath}
# Standar input for absCopyNumber
example_cn = system.file("extdata", "example.cn.txt.gz", package = "absCopyNumber")
example_snv = system.file("extdata", "example.snv.txt.gz", package = "absCopyNumber")

# Standard segmentation file and Maf file, this can also handled by absCopyNumber
example_seg = system.file("extdata", "SNP6_solid_tumor.seg.txt.gz", package = "absCopyNumber")
example_maf = system.file("extdata", "SNP6_solid_tumor.maf.txt.gz", package = "absCopyNumber")
```

> Of note, these data can also be `data.frame`.

#### Standard input

With or without snv data.

```{r}
abs_obj1 = abs_initialize(example_cn)
abs_obj2 = abs_initialize(seg = example_cn, snv = example_snv)
```

We can take a look at `absCopyNumber` object.

```{r}
abs_obj1
```

If no `sample` column provide in file, absCopyNumber will use default 'sample', we can change it to any meaningful name.

```{r}
abs_obj1 = abs_initialize(example_cn, sample_seg = "tumor")

# check
abs_obj1@data
```

Besides using `sample_seg` to set sample name for **one** sample data, it can also be used to specify a column name in input file/data.frame which store sample names.

The same rule can be apply to SNV use `sample_snv` option.

#### Standard segmetation and Maf file



## Old way

The following I will show a basic example which shows you how to use absCopyNumber.

The input copy number file and somatic mutation file should following some rules, this can be called by `abs_supportfiles` function.

### Run absCopyNumber from Local Files


This step should identify local path of copy ratio and snv (optional) files. Here we use example files within package.


```{r ident_filepath}
example_cn = system.file("extdata", "example.cn.txt.gz", package = "absCopyNumber")
example_snv = system.file("extdata", "example.snv.txt.gz", package = "absCopyNumber")
```


Of note, old way inherit from absCNseq package can only handle **Standard Input**, i.e. standard segmentation file for CNV and standard MAF file for SNV is not supported in old way.

The example data come from WES platform, next we specify parameter to run absCopyNumber. We use `run_fromLocal()` function to process data specified as file path.

```{r message=FALSE, warning=FALSE}
my.res.list <- run_fromLocal(seg.fn = example_cn, snv.fn = example_snv, platform="WES", min.seg.len=200)
```

The result is a `list` contains all solutions and other orignal and model information. Solution result is a data.frame named `searchRes` in list. 

```{r}
knitr::kable(my.res.list$searchRes, align = 'c', caption = "Solution Data.Frame")

```

Generally we use top 1 solution, so the corresponding result has been stored at `absCN` data.frame of `my.res.list`. We can also mannually select best solution using our own knowledge. After selecting solution, we calculate absolute copy number by `get_absCopyNumber` function based on purity $\alpha$ and ploidy $\tau$.

```{r}
# select i-th solution
i = 1
seg.CN <- get_absCopyNumber(my.res.list$seg.dat, my.res.list$searchRes[i,"alpha"], my.res.list$searchRes[i,"tau"])  
```

Last, we plot orignal copy number (Raw) and absolute copy number (Absolute) on a same figure.

```{r}
plot_absCopyNumber(seg.CN, chromnum=1)
```

### Run absCopyNumber from data.frame

Sometimes, we process data in R console, so absCopyNumber provide function `run_fromDF` to substitute `run_fromLocal`. Similar arguments and procedure as above, thus we do not show details here.

```{r, message=FALSE}
cn_df = read.table(example_cn, sep = "\t", header = TRUE,  stringsAsFactors = FALSE)
snv_df = read.table(example_snv, sep = "\t", header = TRUE, stringsAsFactors = FALSE)

# or readr::read_tsv
cn_df = as.data.frame(readr::read_tsv(example_cn))
snv_df = as.data.frame(readr::read_tsv(example_snv))
```

Run.

```{r message=FALSE, warning=FALSE}
my.res.list2 = run_fromDF(seg.df = cn_df, snv.df = snv_df, platform = "WES", min.seg.len=200)

identical(my.res.list, my.res.list2)
```

## Comparison between ABSOLUTE and absCopyNumber for SNP

